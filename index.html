<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>BlockPuzzle</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0b0e1a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    :root{
      --bg:#0b0e1a;
      --panel:#131735;
      --cell:#1a1f46;
      --text:#eef1ff;
      --muted:#b6bee6;
      --accent:#7aa2ff;
      --danger:#ff6b6b;
      --ok:#5cffb0;
      --shadow:0 18px 44px rgba(0,0,0,.45);
      --r:18px;
    }
    *{ box-sizing:border-box; font-family: ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial; }
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      padding:18px;
      background:
        radial-gradient(1200px 800px at 18% 10%, #1b2250, transparent 60%),
        radial-gradient(900px 700px at 90% 30%, #1a3a57, transparent 55%),
        radial-gradient(900px 650px at 30% 95%, #3a1d56, transparent 55%),
        var(--bg);
      color:var(--text);
      user-select:none;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
    }
    .app{
      width:min(980px,96vw);
      display:grid;
      grid-template-columns: 1fr 330px;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 900px){
      .app{ grid-template-columns: 1fr; }
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.07);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      padding:14px;
    }
    .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .title{
      font-weight:1000;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.08);
      color:var(--muted);
      font-size:12px;
      font-weight:800;
    }
    .stats{
      display:flex;
      gap:10px;
      font-size:13px;
      color:var(--muted);
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }
    .stats b{ color:var(--text); }
    .btns{ display:flex; gap:8px; }
    button{
      border:0;
      border-radius:12px;
      padding:9px 12px;
      cursor:pointer;
      font-weight:900;
      color:var(--text);
      background: rgba(122,162,255,.18);
      transition: transform .06s ease, background .2s ease;
      user-select:none;
    }
    button:hover{ background: rgba(122,162,255,.26); }
    button:active{ transform: translateY(1px); }
    button.danger{ background: rgba(255,107,107,.18); }
    button.danger:hover{ background: rgba(255,107,107,.26); }

    .gridWrap{
      display:grid;
      place-items:center;
      background: rgba(0,0,0,.14);
      border-radius:22px;
      padding:14px;
      position:relative;
    }
    .grid{
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      gap:6px;
      width:min(560px, 92vw);
      aspect-ratio:1/1;
      padding:10px;
      border-radius:20px;
      background: linear-gradient(180deg, rgba(0,0,0,.28), rgba(0,0,0,.10));
      border:1px solid rgba(255,255,255,.06);
      touch-action:none;
    }
    .cell{
      border-radius:10px;
      background: rgba(255,255,255,.02);
      border:1px solid rgba(255,255,255,.06);
      position:relative;
      overflow:hidden;
      transition: filter .08s ease, transform .08s ease, background .12s ease;
    }
    .cell::after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(110px 70px at 30% 18%, rgba(255,255,255,.06), transparent 60%);
      pointer-events:none;
    }
    .cell.preview-ok{
      outline: 2px solid rgba(92,255,176,.35);
      background: rgba(92,255,176,.10);
    }
    .cell.preview-bad{
      outline: 2px solid rgba(255,107,107,.25);
      background: rgba(255,107,107,.07);
    }
    .filled{
      border-color: rgba(255,255,255,.16);
    }
    .filled .tint{
      position:absolute;
      inset:0;
      opacity:.58;
      mix-blend-mode:screen;
    }
    .filled .shine{
      position:absolute;
      inset:-20%;
      background: radial-gradient(120px 80px at 30% 20%, rgba(255,255,255,.28), transparent 60%);
      opacity:.45;
      transform: rotate(12deg);
      pointer-events:none;
    }
    .cell.clearing{
      animation: flash .18s ease-in-out 2;
    }
    @keyframes flash{
      from{ filter:brightness(1); transform:scale(1); }
      to{ filter:brightness(1.35); transform:scale(1.03); }
    }

    .side h3{
      margin:8px 0 8px;
      font-size:14px;
      color:var(--muted);
      font-weight:1000;
      letter-spacing:.2px;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .tog{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      color:var(--muted);
      user-select:none;
    }
    .tog input{ transform: scale(1.05); }

    .pieces{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
    }
    .pieceCard{
      background: rgba(0,0,0,.14);
      border:1px solid rgba(255,255,255,.07);
      border-radius:16px;
      padding:10px;
      cursor:grab;
      user-select:none;
      touch-action:none;
      transition: transform .08s ease, border-color .2s ease, opacity .2s ease;
      position:relative;
      min-height:96px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .pieceCard:active{ cursor:grabbing; }
    .pieceCard.selected{
      border-color: rgba(122,162,255,.9);
      box-shadow: 0 0 0 2px rgba(122,162,255,.18) inset;
    }
    .pieceCard.used{
      opacity:.30;
      cursor:not-allowed;
    }
    .mini{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:4px;
      width:100%;
      max-width:120px;
      aspect-ratio:1/1;
    }
    .miniCell{
      border-radius:6px;
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.06);
    }
    .miniCell.on{
      border-color: rgba(255,255,255,.14);
    }

    .msg{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.07);
      font-size:13px;
      color:var(--muted);
      line-height:1.35;
    }
    .msg strong{ color:var(--text); }

    .badge{
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      background: rgba(92,255,176,.14);
      border:1px solid rgba(92,255,176,.20);
      color: var(--ok);
      font-weight:1000;
      font-size:12px;
      margin-left:8px;
    }
    .badge2{
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      background: rgba(122,162,255,.14);
      border:1px solid rgba(122,162,255,.22);
      color: var(--accent);
      font-weight:1000;
      font-size:12px;
      margin-left:8px;
    }

    #ghost{
      position:fixed;
      left:0; top:0;
      transform: translate(-9999px,-9999px);
      pointer-events:none;
      z-index:9999;
      opacity:.95;
      filter: drop-shadow(0 14px 26px rgba(0,0,0,.55));
    }
    .ghostGrid{ display:grid; gap:4px; padding:6px; border-radius:14px; }
    .ghostCell{
      width:16px; height:16px;
      border-radius:6px;
      background: rgba(255,255,255,.12);
      border:1px solid rgba(255,255,255,.14);
    }

    .overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(8,10,20,.62);
      backdrop-filter: blur(6px);
      border-radius:22px;
      padding:16px;
    }
    .overlay.show{ display:flex; }
    .modal{
      width:min(420px, 92%);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      padding:16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
    }
    .modal h2{ margin:0 0 6px; font-size:18px; font-weight:1000; }
    .modal p{ margin:0 0 14px; color:var(--muted); font-size:13px; line-height:1.4; }
    .modal .modalRow{
      display:flex; gap:10px; flex-wrap:wrap; justify-content:space-between;
      margin-bottom:12px; color:var(--muted); font-size:13px;
    }
    .modal .modalRow b{ color:var(--text); }
    .modal .actions{ display:flex; gap:10px; justify-content:flex-end; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <div class="top">
        <div class="title">
          BlockPuzzle
          <span class="pill">8×8 • 3 Teile • Combo</span>
        </div>
        <div class="stats">
          <div>Score: <b id="score">0</b></div>
          <div>Best: <b id="best">0</b></div>
          <div>Combo: <b id="combo">0</b></div>
        </div>
        <div class="btns">
          <button id="newBtn" class="danger">New Game</button>
        </div>
      </div>

      <div class="gridWrap">
        <div id="grid" class="grid"></div>

        <div id="overlay" class="overlay">
          <div class="modal">
            <h2>Game Over</h2>
            <p>Kein Teil passt mehr. Starte einfach neu.</p>
            <div class="modalRow">
              <div>Score: <b id="finalScore">0</b></div>
              <div>Best: <b id="finalBest">0</b></div>
              <div>Max Combo: <b id="finalCombo">0</b></div>
            </div>
            <div class="actions">
              <button id="playAgainBtn">Play again</button>
              <button id="closeBtn" class="danger">Close</button>
            </div>
          </div>
        </div>
      </div>

      <div class="msg" id="status">Zieh ein Teil aufs Raster oder tippe es an und tippe dann ins Raster.</div>
    </div>

    <div class="card side">
      <div class="row">
        <h3 style="margin:8px 0;">Teile</h3>
        <label class="tog">
          <input type="checkbox" id="soundToggle" checked />
          Sound
        </label>
      </div>
      <div class="pieces" id="pieces"></div>
      <div class="msg" id="gameMsg">Clears geben viel Punkte. Mehrere Clears hintereinander geben Combo-Bonus.</div>
    </div>
  </div>

  <div id="ghost"></div>

  <script>
  (() => {
    const W=8, H=8;
    const gridEl = document.getElementById("grid");
    const piecesEl = document.getElementById("pieces");
    const scoreEl = document.getElementById("score");
    const bestEl  = document.getElementById("best");
    const comboEl = document.getElementById("combo");
    const statusEl= document.getElementById("status");
    const msgEl   = document.getElementById("gameMsg");
    const newBtn  = document.getElementById("newBtn");
    const ghostEl = document.getElementById("ghost");
    const soundToggle = document.getElementById("soundToggle");

    const overlayEl = document.getElementById("overlay");
    const finalScoreEl = document.getElementById("finalScore");
    const finalBestEl  = document.getElementById("finalBest");
    const finalComboEl = document.getElementById("finalCombo");
    const playAgainBtn = document.getElementById("playAgainBtn");
    const closeBtn     = document.getElementById("closeBtn");

    const COLORS = ["#7aa2ff","#5cffb0","#ffb86b","#ff6b6b","#b37dff","#57d7ff","#ffd166","#06d6a0"];

    const SHAPES = {
      tiny: [
        [[0,0]],
        [[0,0],[1,0]],
        [[0,0],[0,1]],
        [[0,0],[1,0],[0,1]],
        [[0,0],[1,0],[1,1]]
      ],
      small: [
        [[0,0],[1,0],[2,0]],
        [[0,0],[0,1],[0,2]],
        [[0,0],[1,0],[0,1],[1,1]],
        [[0,0],[1,0],[2,0],[1,1]],
        [[0,0],[1,0],[1,1],[2,1]],
        [[1,0],[2,0],[0,1],[1,1]]
      ],
      medium: [
        [[0,0],[1,0],[2,0],[3,0]],
        [[0,0],[0,1],[0,2],[0,3]],
        [[0,0],[1,0],[2,0],[0,1],[1,1],[2,1]],
        [[0,0],[0,1],[0,2],[1,2]],
        [[1,0],[1,1],[1,2],[0,2]]
      ],
      big: [
        [[0,0],[1,0],[2,0],[3,0],[4,0]],
        [[0,0],[0,1],[0,2],[0,3],[0,4]],
        [[0,0],[1,0],[2,0],[3,0],[0,1]],
        [[0,0],[1,0],[2,0],[2,1],[2,2]]
      ]
    };

    let board;
    let pieces;
    let selectedIndex=-1;
    let score=0;
    let best=0;

    let combo=0;
    let maxCombo=0;

    let dragging=null;
    let lastHoverCell=null;

    let bag=[];
    let audioCtx=null;

    const randInt=(n)=>Math.floor(Math.random()*n);

    function beep(type){
      if(!soundToggle.checked) return;
      try{
        audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        const presets = {
          pick:{f:420,d:0.05},
          place:{f:520,d:0.06},
          clear:{f:760,d:0.10},
          bad:{f:190,d:0.09},
          over:{f:130,d:0.22}
        };
        const p = presets[type] || presets.place;
        osc.type="sine";
        osc.frequency.setValueAtTime(p.f, t);
        gain.gain.setValueAtTime(0.0001, t);
        gain.gain.exponentialRampToValueAtTime(0.20, t+0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, t+p.d);
        osc.start(t);
        osc.stop(t+p.d+0.02);
      }catch(e){}
    }

    function normalizeShape(shape){
      let minX=Infinity, minY=Infinity;
      for(const [x,y] of shape){ minX=Math.min(minX,x); minY=Math.min(minY,y); }
      return shape.map(([x,y])=>[x-minX,y-minY]);
    }

    function loadBest(){
      const v = Number(localStorage.getItem("bp_best_like")||0);
      best = Number.isFinite(v)?v:0;
      bestEl.textContent=best;
    }
    function saveBest(){
      if(score>best){
        best=score;
        localStorage.setItem("bp_best_like", String(best));
        bestEl.textContent=best;
      }
    }

    function setStatus(html){ statusEl.innerHTML=html; }
    function showGameOver(){
      overlayEl.classList.add("show");
      finalScoreEl.textContent=score;
      finalBestEl.textContent=best;
      finalComboEl.textContent=maxCombo;
    }
    function hideGameOver(){ overlayEl.classList.remove("show"); }

    function emptyBoard(){
      board = Array.from({length:H}, ()=>Array.from({length:W}, ()=>null));
    }

    function refillBag(){
      const pack=[];
      for(let i=0;i<10;i++) pack.push({cat:"tiny",idx:i%SHAPES.tiny.length});
      for(let i=0;i<8;i++)  pack.push({cat:"small",idx:i%SHAPES.small.length});
      for(let i=0;i<5;i++)  pack.push({cat:"medium",idx:i%SHAPES.medium.length});
      for(let i=0;i<2;i++)  pack.push({cat:"big",idx:i%SHAPES.big.length});
      for(let i=pack.length-1;i>0;i--){
        const j=randInt(i+1);
        [pack[i],pack[j]]=[pack[j],pack[i]];
      }
      bag=pack;
    }
    function nextShape(){
      if(bag.length===0) refillBag();
      const pick=bag.pop();
      return SHAPES[pick.cat][pick.idx];
    }

    function drawPieces(n=3){
      const out=[];
      for(let i=0;i<n;i++){
        out.push({shape:nextShape(), color:COLORS[randInt(COLORS.length)], used:false});
      }
      const sizes=out.map(p=>normalizeShape(p.shape).length);
      if(sizes.filter(s=>s>=5).length===3){
        out[randInt(3)]={shape:SHAPES.tiny[randInt(SHAPES.tiny.length)], color:COLORS[randInt(COLORS.length)], used:false};
      }
      return out;
    }
    function allPiecesUsed(){ return pieces.every(p=>p.used); }

    function canPlace(piece,gx,gy){
      const shape=normalizeShape(piece.shape);
      for(const [dx,dy] of shape){
        const x=gx+dx,y=gy+dy;
        if(x<0||x>=W||y<0||y>=H) return false;
        if(board[y][x]!==null) return false;
      }
      return true;
    }
    function placePiece(piece,gx,gy){
      const shape=normalizeShape(piece.shape);
      for(const [dx,dy] of shape){
        board[gy+dy][gx+dx]=piece.color;
      }
      return shape.length;
    }

    function clearLinesWithAnimation(){
      const fullRows=[], fullCols=[];
      for(let y=0;y<H;y++) if(board[y].every(v=>v!==null)) fullRows.push(y);
      for(let x=0;x<W;x++){
        let full=true;
        for(let y=0;y<H;y++){ if(board[y][x]===null){ full=false; break; } }
        if(full) fullCols.push(x);
      }
      if(fullRows.length===0 && fullCols.length===0) return {lines:0,gained:0};

      const cells=gridEl.querySelectorAll(".cell");
      const mark=new Set();
      for(const y of fullRows) for(let x=0;x<W;x++) mark.add(y*W+x);
      for(const x of fullCols) for(let y=0;y<H;y++) mark.add(y*W+x);
      for(const idx of mark) cells[idx]?.classList.add("clearing");

      setTimeout(()=>{
        for(const y of fullRows) for(let x=0;x<W;x++) board[y][x]=null;
        for(const x of fullCols) for(let y=0;y<H;y++) board[y][x]=null;
        renderGrid(null);
      },130);

      const lines=fullRows.length+fullCols.length;
      const gained=lines*12+Math.max(0,lines-1)*8;
      return {lines,gained};
    }

    function anyMoveExists(){
      for(const p of pieces){
        if(p.used) continue;
        for(let y=0;y<H;y++) for(let x=0;x<W;x++){
          if(canPlace(p,x,y)) return true;
        }
      }
      return false;
    }

    function updateHUD(){
      scoreEl.textContent=score;
      comboEl.textContent=combo;
      saveBest();
      bestEl.textContent=best;
    }

    function renderGrid(preview){
      gridEl.innerHTML="";
      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          const d=document.createElement("div");
          d.className="cell";
          const c=board[y][x];
          if(c){
            d.classList.add("filled");
            d.style.background =
              `radial-gradient(120px 80px at 30% 18%, rgba(255,255,255,.18), transparent 62%),
               linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.26))`;
            const tint=document.createElement("div");
            tint.className="tint";
            tint.style.background=c;
            const shine=document.createElement("div");
            shine.className="shine";
            d.appendChild(tint);
            d.appendChild(shine);
          } else {
            d.style.backgroundColor=((x+y)%2===0)?"rgba(255,255,255,.028)":"rgba(255,255,255,.02)";
          }

          if(preview){
            for(const [px,py] of preview.cells){
              if(px===x && py===y){
                d.classList.add(preview.ok?"preview-ok":"preview-bad");
                break;
              }
            }
          }

          d.addEventListener("click", ()=>{
            if(selectedIndex<0) return;
            tryPlaceAt(selectedIndex,x,y);
          });

          d.addEventListener("pointerenter", ()=>{
            if(!dragging) return;
            setPreviewFromCell(x,y);
          });

          gridEl.appendChild(d);
        }
      }
    }

    function renderPieces(){
      piecesEl.innerHTML="";
      pieces.forEach((p,idx)=>{
        const card=document.createElement("div");
        card.className="pieceCard";
        if(idx===selectedIndex) card.classList.add("selected");
        if(p.used) card.classList.add("used");

        const mini=document.createElement("div");
        mini.className="mini";
        const shape=normalizeShape(p.shape);
        const coords=new Set(shape.map(([x,y])=>`${x},${y}`));
        let maxX=0,maxY=0;
        for(const [x,y] of shape){ maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); }
        const offX=Math.floor((5-(maxX+1))/2);
        const offY=Math.floor((5-(maxY+1))/2);

        for(let y=0;y<5;y++){
          for(let x=0;x<5;x++){
            const c=document.createElement("div");
            c.className="miniCell";
            const sx=x-offX, sy=y-offY;
            if(coords.has(`${sx},${sy}`)){
              c.classList.add("on");
              c.style.background=p.color;
              c.style.opacity="0.80";
            }
            mini.appendChild(c);
          }
        }
        card.appendChild(mini);

        card.addEventListener("click", ()=>{
          if(p.used) return;
          if(dragging) return;
          selectedIndex=(selectedIndex===idx)?-1:idx;
          beep("pick");
          renderPieces();
          renderGrid(null);
          setStatus(selectedIndex>=0?"Teil ausgewählt. Tippe ins Raster oder zieh es rüber.":"Auswahl aufgehoben.");
        });

        card.addEventListener("pointerdown", (e)=>{
          if(p.used) return;
          card.setPointerCapture(e.pointerId);
          dragging={index:idx, piece:p};
          selectedIndex=idx;
          beep("pick");
          renderPieces();
          buildGhost(p);
          moveGhost(e.clientX,e.clientY);
          setStatus("Zieh das Teil aufs Raster und lass los.");
        });

        card.addEventListener("pointermove", (e)=>{
          if(!dragging || dragging.index!==idx) return;
          moveGhost(e.clientX,e.clientY);
          const cell=cellFromPoint(e.clientX,e.clientY);
          if(cell) setPreviewFromCell(cell.x,cell.y); else clearPreview();
        });

        card.addEventListener("pointerup", (e)=>{
          if(!dragging || dragging.index!==idx) return;
          finishDragAtPoint(e.clientX,e.clientY);
        });

        card.addEventListener("pointercancel", ()=>{
          if(!dragging || dragging.index!==idx) return;
          cancelDrag();
        });

        piecesEl.appendChild(card);
      });
    }

    function buildGhost(piece){
      const shape=normalizeShape(piece.shape);
      let maxX=0,maxY=0;
      for(const [x,y] of shape){ maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); }
      const w=maxX+1,h=maxY+1;
      ghostEl.innerHTML="";
      const g=document.createElement("div");
      g.className="ghostGrid";
      g.style.gridTemplateColumns=`repeat(${w},16px)`;
      const set=new Set(shape.map(([x,y])=>`${x},${y}`));
      for(let yy=0;yy<h;yy++){
        for(let xx=0;xx<w;xx++){
          const c=document.createElement("div");
          c.className="ghostCell";
          if(set.has(`${xx},${yy}`)){
            c.style.background=piece.color;
            c.style.opacity="0.75";
          } else {
            c.style.opacity="0";
            c.style.border="0";
            c.style.background="transparent";
          }
          g.appendChild(c);
        }
      }
      ghostEl.appendChild(g);
    }
    function moveGhost(x,y){ ghostEl.style.transform=`translate(${x+12}px,${y+12}px)`; }
    function hideGhost(){ ghostEl.style.transform="translate(-9999px,-9999px)"; ghostEl.innerHTML=""; }

    function cellFromPoint(clientX,clientY){
      const r=gridEl.getBoundingClientRect();
      const inside=clientX>=r.left && clientX<=r.right && clientY>=r.top && clientY<=r.bottom;
      if(!inside) return null;
      const els=gridEl.querySelectorAll(".cell");
      let best=null,bestDist=Infinity;
      els.forEach((el,idx)=>{
        const cr=el.getBoundingClientRect();
        const cx=(cr.left+cr.right)/2, cy=(cr.top+cr.bottom)/2;
        const dx=clientX-cx, dy=clientY-cy;
        const dist=dx*dx+dy*dy;
        if(dist<bestDist){ bestDist=dist; best={x:idx%W,y:Math.floor(idx/W)}; }
      });
      return best;
    }

    function setPreviewFromCell(x,y){
      if(!dragging) return;
      const p=dragging.piece;
      const shape=normalizeShape(p.shape);
      const cells=shape.map(([dx,dy])=>[x+dx,y+dy]);
      const ok=canPlace(p,x,y);
      lastHoverCell={x,y,ok};
      renderGrid({cells,ok});
    }
    function clearPreview(){ lastHoverCell=null; renderGrid(null); }

    function tryPlaceAt(pieceIndex,x,y){
      if(overlayEl.classList.contains("show")) return;
      const p=pieces[pieceIndex];
      if(!p || p.used) return;

      if(!canPlace(p,x,y)){
        beep("bad");
        setStatus("Passt dort nicht. Versuch eine andere Position.");
        return;
      }

      const blocks=placePiece(p,x,y);
      p.used=true;
      score += blocks;

      const {lines,gained}=clearLinesWithAnimation();
      if(lines>0){
        combo += 1;
        maxCombo = Math.max(maxCombo, combo);
        const comboBonus = Math.min(40, (combo-1)*8);
        score += gained + comboBonus;
        beep("clear");
        setStatus(`Clear! <span class="badge">+${gained}</span>${combo>1?`<span class="badge2">Combo +${comboBonus}</span>`:""}`);
      } else {
        combo = 0;
        beep("place");
        setStatus(`Platziert. <span class="badge">+${blocks}</span>`);
      }

      selectedIndex=-1;
      updateHUD();
      renderPieces();
      renderGrid(null);

      if(allPiecesUsed()){
        pieces = drawPieces(3);
        msgEl.textContent="Neue Teile!";
        renderPieces();
      }

      setTimeout(()=>{
        if(!anyMoveExists()){
          beep("over");
          updateHUD();
          showGameOver();
          setStatus("<strong>Game Over.</strong> Kein Teil passt mehr.");
        }
      },160);
    }

    function finishDragAtPoint(clientX,clientY){
      const idx=dragging.index;
      const cell=cellFromPoint(clientX,clientY);
      if(cell) tryPlaceAt(idx,cell.x,cell.y);
      else if(lastHoverCell) tryPlaceAt(idx,lastHoverCell.x,lastHoverCell.y);
      else setStatus("Nicht auf dem Raster losgelassen. Drag abgebrochen.");
      cancelDrag();
    }
    function cancelDrag(){ dragging=null; hideGhost(); clearPreview(); }

    function newGame(){
      hideGameOver();
      score=0; combo=0; maxCombo=0;
      selectedIndex=-1;
      emptyBoard();
      if(bag.length<6) refillBag();
      pieces = drawPieces(3);
      updateHUD();
      renderPieces();
      renderGrid(null);
      setStatus("Zieh ein Teil aufs Raster oder tippe es an und tippe dann ins Raster.");
      msgEl.textContent="Clears geben viel Punkte. Combos sind der Turbo.";
    }

    newBtn.addEventListener("click", newGame);
    playAgainBtn.addEventListener("click", newGame);
    closeBtn.addEventListener("click", hideGameOver);

    loadBest();
    refillBag();
    newGame();
  })();
  </script>

  <!-- Service Worker registrieren -->
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./sw.js");
    }
  </script>
</body>
</html>
